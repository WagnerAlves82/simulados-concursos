"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/simulado/page",{

/***/ "(app-pages-browser)/./src/lib/questoesServices.ts":
/*!*************************************!*\
  !*** ./src/lib/questoesServices.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuestoesService: function() { return /* binding */ QuestoesService; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n// src/lib/questoesServices.ts - VERSÃO CORRIGIDA\n\n// CONFIGURAÇÃO DO LIMITE GRATUITO\nconst LIMITE_QUESTOES_GRATUITAS = 3;\nclass QuestoesService {\n    // Método auxiliar para verificar login\n    async isUsuarioLogado() {\n        try {\n            const { data: { user }, error } = await this.supabase.auth.getUser();\n            return !error && !!user;\n        } catch (error) {\n            return false;\n        }\n    }\n    async buscarCargos() {\n        try {\n            const { data: cargos, error } = await this.supabase.from(\"cargos\").select(\"id, nome, descricao, nivel_escolaridade, banca\").eq(\"ativo\", true).order(\"nome\");\n            if (error) {\n                console.error(\"Erro ao buscar cargos:\", error);\n                throw new Error(error.message);\n            }\n            return cargos || [];\n        } catch (error) {\n            console.error(\"Erro ao buscar cargos:\", error);\n            throw error;\n        }\n    }\n    async buscarQuestoesPorCargo(cargoId) {\n        if (!cargoId) throw new Error(\"cargoId \\xe9 obrigat\\xf3rio\");\n        try {\n            console.log(\"Iniciando busca por cargoId:\", cargoId);\n            // 1. Buscar TODAS as questões\n            const { data: questoes, error: questoesError } = await this.supabase.from(\"questoes\").select(\"*\").eq(\"cargo_id\", cargoId).eq(\"ativo\", true).order(\"area_id\").order(\"id\");\n            if (questoesError) {\n                console.error(\"Erro na query de quest\\xf5es:\", questoesError);\n                throw new Error(questoesError.message);\n            }\n            if (!questoes || questoes.length === 0) {\n                console.log(\"Nenhuma quest\\xe3o encontrada para o cargo:\", cargoId);\n                return {\n                    questoes: [],\n                    areas: [],\n                    total: 0\n                };\n            }\n            console.log(\"Quest\\xf5es encontradas: \".concat(questoes.length));\n            // 2. Buscar áreas - CORRIGIDO (evita problema com .in())\n            const areaIds = [\n                ...new Set(questoes.map((q)=>q.area_id).filter((id)=>id !== null))\n            ];\n            console.log(\"Area IDs a buscar:\", areaIds);\n            const { data: areas, error: areasError } = await this.supabase.from(\"areas_conhecimento\").select(\"*\");\n            // Filtrar apenas as áreas que têm questões\n            const areasComQuestoes = (areas === null || areas === void 0 ? void 0 : areas.filter((area)=>areaIds.includes(area.id))) || [];\n            // ADICIONAR verificação de erro:\n            if (areasError) {\n                console.error(\"Erro ao buscar \\xe1reas:\", areasError);\n                throw new Error(\"Erro ao buscar \\xe1reas: \".concat(areasError.message));\n            }\n            console.log(\"Todas as \\xe1reas do banco:\", areas);\n            console.log(\"\\xc1reas filtradas com quest\\xf5es:\", areasComQuestoes);\n            const { data: cargoAreas, error: cargoAreasError } = await this.supabase.from(\"cargo_areas\").select(\"*\").eq(\"cargo_id\", cargoId);\n            if (cargoAreasError) {\n                console.warn(\"Erro ao buscar cargo_areas:\", cargoAreasError);\n            }\n            // 3. Criar mapas para relacionamento - CORRIGIDO\n            const areaMap = areas && areas.length > 0 ? areas.reduce((acc, area)=>{\n                acc[area.id] = area.nome;\n                return acc;\n            }, {}) : {};\n            console.log(\"Area map criado:\", areaMap);\n            const cargoAreaMap = (cargoAreas === null || cargoAreas === void 0 ? void 0 : cargoAreas.reduce((acc, ca)=>{\n                acc[ca.area_id] = {\n                    numero_questoes: ca.numero_questoes,\n                    peso: ca.peso || 1.0\n                };\n                return acc;\n            }, {})) || {};\n            // 4. Montar questões completas - CORRIGIDO\n            const questoesCompletas = questoes.map((q)=>{\n                var _cargoAreaMap_q_area_id;\n                return {\n                    ...q,\n                    area_nome: areaMap[q.area_id] || \"\\xc1rea Desconhecida\",\n                    peso_area: ((_cargoAreaMap_q_area_id = cargoAreaMap[q.area_id]) === null || _cargoAreaMap_q_area_id === void 0 ? void 0 : _cargoAreaMap_q_area_id.peso) || 1.0\n                };\n            });\n            // 5. Montar estatísticas das áreas - CORRIGIDO\n            // 5. Montar estatísticas das áreas - CORRIGIDO\n            let areasEstatisticas;\n            if (cargoAreas && cargoAreas.length > 0) {\n                areasEstatisticas = cargoAreas.map((ca)=>{\n                    // CONTAR QUESTÕES REAIS EM VEZ DE USAR VALOR FIXO\n                    const questoesDaArea = questoes.filter((q)=>q.area_id === ca.area_id);\n                    return {\n                        id: ca.area_id,\n                        nome: areaMap[ca.area_id] || \"\\xc1rea Desconhecida\",\n                        total_questoes: questoesDaArea.length,\n                        peso: ca.peso || 1.0,\n                        questoes_respondidas: 0,\n                        acertos: 0,\n                        percentual: 0\n                    };\n                });\n            } else {\n                areasEstatisticas = areaIds.map((areaId)=>{\n                    const questoesDaArea = questoes.filter((q)=>q.area_id === areaId);\n                    return {\n                        id: areaId,\n                        nome: areaMap[areaId] || \"\\xc1rea Desconhecida\",\n                        total_questoes: questoesDaArea.length,\n                        peso: 1.0,\n                        questoes_respondidas: 0,\n                        acertos: 0,\n                        percentual: 0\n                    };\n                });\n            }\n            console.log(\"Busca conclu\\xedda: \".concat(questoesCompletas.length, \" quest\\xf5es, \").concat(areasEstatisticas.length, \" \\xe1reas\"));\n            return {\n                questoes: questoesCompletas,\n                areas: areasEstatisticas,\n                total: questoes.length\n            };\n        } catch (error) {\n            console.error(\"Erro geral ao buscar quest\\xf5es:\", error);\n            throw error;\n        }\n    }\n    /**\r\n   * Gera um simulado personalizado baseado na distribuição por área e dificuldade\r\n   */ async gerarSimuladoPersonalizado(cargoId) {\n        let dificuldades = arguments.length > 1 && arguments[1] !== void 0 // Níveis de dificuldade a incluir\n         ? arguments[1] : [\n            1,\n            2,\n            3\n        ];\n        try {\n            console.log(\"Iniciando gera\\xe7\\xe3o do simulado para cargo:\", cargoId, \"dificuldades:\", dificuldades);\n            // 1. Buscar TODAS as questões do cargo com filtro de dificuldade\n            const { data: todasQuestoes, error: questoesError } = await this.supabase.from(\"questoes\").select(\"*\").eq(\"cargo_id\", cargoId).eq(\"ativo\", true).in(\"dificuldade\", dificuldades);\n            if (questoesError) {\n                console.error(\"Erro ao buscar quest\\xf5es:\", questoesError);\n                throw new Error(questoesError.message);\n            }\n            if (!todasQuestoes || todasQuestoes.length === 0) {\n                console.warn(\"Nenhuma quest\\xe3o encontrada para o cargo e dificuldades especificadas\");\n                return [];\n            }\n            console.log(\"Total de quest\\xf5es dispon\\xedveis: \".concat(todasQuestoes.length));\n            // 2. Buscar configuração de cargo_areas\n            const { data: cargoAreas, error: configError } = await this.supabase.from(\"cargo_areas\").select(\"area_id, numero_questoes\").eq(\"cargo_id\", cargoId);\n            if (configError) {\n                console.error(\"Erro ao buscar configura\\xe7\\xe3o:\", configError);\n            }\n            console.log(\"Configura\\xe7\\xf5es encontradas: \".concat((cargoAreas === null || cargoAreas === void 0 ? void 0 : cargoAreas.length) || 0));\n            // 3. Buscar dados complementares para questões completas - CORRIGIDO\n            const areaIds = [\n                ...new Set(todasQuestoes.map((q)=>q.area_id).filter((id)=>id !== null))\n            ];\n            const { data: areas, error: areasError } = await this.supabase.from(\"areas_conhecimento\").select(\"*\");\n            // Filtrar apenas as áreas necessárias\n            const areasComQuestoes = (areas === null || areas === void 0 ? void 0 : areas.filter((area)=>areaIds.includes(area.id))) || [];\n            if (areasError) {\n                console.error(\"Erro ao buscar \\xe1reas para simulado:\", areasError);\n            }\n            const { data: configAreas } = await this.supabase.from(\"cargo_areas\").select(\"*\").eq(\"cargo_id\", cargoId);\n            // Criar mapas - CORRIGIDO\n            const areaMap = areasComQuestoes && areasComQuestoes.length > 0 ? areasComQuestoes.reduce((acc, area)=>{\n                acc[area.id] = area.nome;\n                return acc;\n            }, {}) : {};\n            const pesoMap = (configAreas === null || configAreas === void 0 ? void 0 : configAreas.reduce((acc, config)=>{\n                acc[config.area_id] = config.peso || 1.0;\n                return acc;\n            }, {})) || {};\n            // Montar questões completas - CORRIGIDO\n            const questoesCompletas = todasQuestoes.map((q)=>({\n                    ...q,\n                    area_nome: areaMap[q.area_id] || \"\\xc1rea Desconhecida\",\n                    peso_area: pesoMap[q.area_id] || 1.0\n                }));\n            let questoesSimulado = [];\n            // 4. Se não há configuração, usar distribuição simples com mistura de dificuldades\n            if (!cargoAreas || cargoAreas.length === 0) {\n                console.log(\"Sem configura\\xe7\\xe3o espec\\xedfica, misturando quest\\xf5es por dificuldade\");\n                // Separar questões por dificuldade\n                const questoesPorDificuldade = dificuldades.reduce((acc, nivel)=>{\n                    acc[nivel] = questoesCompletas.filter((q)=>q.dificuldade === nivel);\n                    return acc;\n                }, {});\n                // Calcular quantas questões de cada dificuldade incluir\n                const totalDesejado = Math.min(120, questoesCompletas.length);\n                const questoesPorNivel = Math.floor(totalDesejado / dificuldades.length);\n                const resto = totalDesejado % dificuldades.length;\n                dificuldades.forEach((nivel, index)=>{\n                    const quantidade = questoesPorNivel + (index < resto ? 1 : 0);\n                    const disponíveis = questoesPorDificuldade[nivel] || [];\n                    const embaralhadas = this.embaralharArray(disponíveis);\n                    questoesSimulado.push(...embaralhadas.slice(0, quantidade));\n                });\n                questoesSimulado = this.embaralharArray(questoesSimulado);\n            } else {\n                // 5. Usar configuração específica por área, misturando dificuldades dentro de cada área\n                for (const config of cargoAreas){\n                    const questoesDaArea = questoesCompletas.filter((q)=>q.area_id === config.area_id);\n                    console.log(\"\\xc1rea \".concat(config.area_id, \": \").concat(questoesDaArea.length, \" quest\\xf5es dispon\\xedveis, \").concat(config.numero_questoes, \" solicitadas\"));\n                    if (questoesDaArea.length > 0) {\n                        // Separar por dificuldade dentro da área\n                        const questoesPorDificuldade = dificuldades.reduce((acc, nivel)=>{\n                            acc[nivel] = questoesDaArea.filter((q)=>q.dificuldade === nivel);\n                            return acc;\n                        }, {});\n                        // Distribuir questões da área proporcionalmente entre dificuldades\n                        const questoesDaAreaSelecionadas = [];\n                        const questoesPorNivel = Math.floor(config.numero_questoes / dificuldades.length);\n                        const resto = config.numero_questoes % dificuldades.length;\n                        dificuldades.forEach((nivel, index)=>{\n                            const quantidade = questoesPorNivel + (index < resto ? 1 : 0);\n                            const disponíveis = questoesPorDificuldade[nivel] || [];\n                            const embaralhadas = this.embaralharArray(disponíveis);\n                            questoesDaAreaSelecionadas.push(...embaralhadas.slice(0, quantidade));\n                        });\n                        questoesSimulado.push(...questoesDaAreaSelecionadas);\n                        console.log(\"Selecionadas \".concat(questoesDaAreaSelecionadas.length, \" quest\\xf5es da \\xe1rea \").concat(config.area_id));\n                    }\n                }\n                questoesSimulado = this.embaralharArray(questoesSimulado);\n            }\n            const simuladoFinal = questoesSimulado;\n            console.log(\"Simulado final gerado: \".concat(simuladoFinal.length, \" quest\\xf5es\"));\n            console.log(\"Distribui\\xe7\\xe3o por \\xe1rea:\", simuladoFinal.reduce((acc, q)=>{\n                acc[q.area_nome] = (acc[q.area_nome] || 0) + 1;\n                return acc;\n            }, {}));\n            return simuladoFinal;\n        } catch (error) {\n            console.error(\"Erro ao gerar simulado:\", error);\n            throw error;\n        }\n    }\n    // Método para verificar se usuário deve ver modal\n    async deveExibirModalLogin(questoesRespondidas) {\n        const isLogado = await this.isUsuarioLogado();\n        if (isLogado || questoesRespondidas < LIMITE_QUESTOES_GRATUITAS) {\n            return {\n                exibirModal: false,\n                beneficios: [],\n                questoesTotais: 0,\n                questoesLiberadas: 0\n            };\n        }\n        return {\n            exibirModal: true,\n            beneficios: [\n                \"Acesso completo a todas as quest\\xf5es do simulado\",\n                \"Relat\\xf3rios detalhados de desempenho por \\xe1rea\",\n                \"Cron\\xf4metro e controle de tempo personalizado\",\n                \"Acompanhamento de evolu\\xe7\\xe3o e estat\\xedsticas\",\n                \"Hist\\xf3rico completo de simulados realizados\",\n                \"Quest\\xf5es sempre atualizadas conforme o edital\",\n                \"Sincroniza\\xe7\\xe3o entre dispositivos\",\n                \"Coment\\xe1rios detalhados com explica\\xe7\\xf5es das regras\"\n            ],\n            questoesTotais: 0,\n            questoesLiberadas: LIMITE_QUESTOES_GRATUITAS\n        };\n    }\n    async testarConexao() {\n        try {\n            console.log(\"Testando conex\\xe3o com Supabase...\");\n            const { data, error } = await this.supabase.from(\"questoes\").select(\"id\").limit(1);\n            if (error) {\n                console.error(\"Erro de conex\\xe3o:\", error);\n                throw error;\n            }\n            console.log(\"Conex\\xe3o bem-sucedida\");\n            return true;\n        } catch (error) {\n            console.error(\"Erro geral na conex\\xe3o:\", error);\n            throw error;\n        }\n    }\n    /**\r\n   * Busca questões de uma área específica\r\n   */ async buscarQuestoesPorArea(cargoId, areaId, limite) {\n        try {\n            let questoesQuery = this.supabase.from(\"questoes\").select(\"*\").eq(\"cargo_id\", cargoId).eq(\"area_id\", areaId).eq(\"ativo\", true).order(\"id\");\n            if (limite) {\n                questoesQuery = questoesQuery.limit(limite);\n            }\n            const { data: questoes, error: questoesError } = await questoesQuery;\n            if (questoesError) throw new Error(questoesError.message);\n            if (!questoes || questoes.length === 0) {\n                return [];\n            }\n            // Buscar nome da área - CORRIGIDO\n            const { data: area, error: areaError } = await this.supabase.from(\"areas_conhecimento\").select(\"nome\").eq(\"id\", areaId).single();\n            if (areaError) {\n                console.warn(\"Erro ao buscar nome da \\xe1rea:\", areaError);\n            }\n            // Buscar peso da área\n            const { data: cargoArea, error: cargoAreaError } = await this.supabase.from(\"cargo_areas\").select(\"peso\").eq(\"cargo_id\", cargoId).eq(\"area_id\", areaId).single();\n            if (cargoAreaError) {\n                console.warn(\"Erro ao buscar configura\\xe7\\xe3o da \\xe1rea:\", cargoAreaError);\n            }\n            // Montar questões completas - CORRIGIDO\n            const questoesCompletas = questoes.map((q)=>({\n                    ...q,\n                    area_nome: (area === null || area === void 0 ? void 0 : area.nome) || \"\\xc1rea Desconhecida\",\n                    peso_area: (cargoArea === null || cargoArea === void 0 ? void 0 : cargoArea.peso) || 1.0\n                }));\n            return questoesCompletas;\n        } catch (error) {\n            console.error(\"Erro ao buscar quest\\xf5es por \\xe1rea:\", error);\n            throw error;\n        }\n    }\n    /**\r\n   * Busca estatísticas de desempenho por área para um usuário\r\n   */ async buscarEstatisticasUsuario(userId, cargoId) {\n        try {\n            // Buscar estatísticas\n            const { data: stats, error: statsError } = await this.supabase.from(\"estatisticas_areas\").select(\"*\").eq(\"user_id\", userId).eq(\"cargo_id\", cargoId);\n            if (statsError) throw new Error(statsError.message);\n            if (!stats || stats.length === 0) return [];\n            // Buscar nomes das áreas - CORRIGIDO\n            const areaIds = stats.map((s)=>s.area_id).filter((id)=>id !== null);\n            const { data: areas, error: areasError } = await this.supabase.from(\"areas_conhecimento\").select(\"*\").in(\"id\", areaIds);\n            if (areasError) {\n                console.warn(\"Erro ao buscar \\xe1reas:\", areasError);\n            }\n            // Buscar pesos das áreas\n            const { data: cargoAreas, error: cargoAreasError } = await this.supabase.from(\"cargo_areas\").select(\"*\").eq(\"cargo_id\", cargoId).in(\"area_id\", areaIds);\n            if (cargoAreasError) {\n                console.warn(\"Erro ao buscar configura\\xe7\\xe3o das \\xe1reas:\", cargoAreasError);\n            }\n            // Criar mapas - CORRIGIDO\n            const areaMap = areas && areas.length > 0 ? areas.reduce((acc, area)=>{\n                acc[area.id] = area.nome;\n                return acc;\n            }, {}) : {};\n            const pesoMap = (cargoAreas === null || cargoAreas === void 0 ? void 0 : cargoAreas.reduce((acc, config)=>{\n                acc[config.area_id] = config.peso || 1.0;\n                return acc;\n            }, {})) || {};\n            // Montar estatísticas - CORRIGIDO\n            return stats.map((s)=>({\n                    id: s.area_id,\n                    nome: areaMap[s.area_id] || \"\\xc1rea Desconhecida\",\n                    total_questoes: s.total_questoes || 0,\n                    peso: pesoMap[s.area_id] || 1.0,\n                    questoes_respondidas: s.total_questoes || 0,\n                    acertos: s.acertos || 0,\n                    percentual: s.percentual || 0\n                }));\n        } catch (error) {\n            console.error(\"Erro ao buscar estat\\xedsticas:\", error);\n            throw error;\n        }\n    }\n    /**\r\n   * Salva resultado de simulado\r\n   */ async salvarResultadoSimulado(userId, cargoId, questoes, respostas, tempoGasto) {\n        try {\n            let pontuacaoTotal = 0;\n            let pesoTotal = 0;\n            let acertos = 0;\n            questoes.forEach((q)=>{\n                pesoTotal += q.peso_area;\n                if (respostas[q.id] === q.resposta_correta) {\n                    acertos++;\n                    pontuacaoTotal += q.peso_area;\n                }\n            });\n            const percentualAcertos = acertos / questoes.length * 100;\n            const { data: simulado, error: simuladoError } = await this.supabase.from(\"simulados\").insert({\n                user_id: userId,\n                cargo_id: cargoId,\n                tipo: \"personalizado\",\n                status: \"concluido\",\n                data_conclusao: new Date().toISOString(),\n                tempo_gasto: tempoGasto,\n                pontuacao_total: pontuacaoTotal,\n                percentual_acertos: percentualAcertos\n            }).select(\"id\").single();\n            if (simuladoError) throw new Error(simuladoError.message);\n            const questoesSimulado = questoes.map((q, index)=>({\n                    simulado_id: simulado.id,\n                    questao_id: q.id,\n                    ordem: index + 1,\n                    resposta_usuario: respostas[q.id] || null,\n                    correta: respostas[q.id] === q.resposta_correta,\n                    tempo_resposta: Math.floor(tempoGasto / questoes.length)\n                }));\n            const { error: questoesError } = await this.supabase.from(\"simulado_questoes\").insert(questoesSimulado);\n            if (questoesError) throw new Error(questoesError.message);\n            await this.atualizarEstatisticasAreas(userId, cargoId, questoes, respostas);\n            return simulado.id;\n        } catch (error) {\n            console.error(\"Erro ao salvar resultado:\", error);\n            throw error;\n        }\n    }\n    /**\r\n   * Atualiza estatísticas por área\r\n   */ async atualizarEstatisticasAreas(userId, cargoId, questoes, respostas) {\n        const questoesPorArea = questoes.reduce((acc, q)=>{\n            if (!acc[q.area_id]) {\n                acc[q.area_id] = [];\n            }\n            acc[q.area_id].push(q);\n            return acc;\n        }, {});\n        for (const [areaId, questoesDaArea] of Object.entries(questoesPorArea)){\n            const areaIdNum = parseInt(areaId);\n            const acertos = questoesDaArea.filter((q)=>respostas[q.id] === q.resposta_correta).length;\n            const total = questoesDaArea.length;\n            const { data: estatisticaExistente } = await this.supabase.from(\"estatisticas_areas\").select(\"*\").eq(\"user_id\", userId).eq(\"cargo_id\", cargoId).eq(\"area_id\", areaIdNum).single();\n            if (estatisticaExistente) {\n                const novoTotal = (estatisticaExistente.total_questoes || 0) + total;\n                const novosAcertos = (estatisticaExistente.acertos || 0) + acertos;\n                const novoPercentual = novosAcertos / novoTotal * 100;\n                await this.supabase.from(\"estatisticas_areas\").update({\n                    total_questoes: novoTotal,\n                    acertos: novosAcertos,\n                    percentual: novoPercentual,\n                    ultima_atualizacao: new Date().toISOString()\n                }).eq(\"id\", estatisticaExistente.id);\n            } else {\n                const percentual = acertos / total * 100;\n                await this.supabase.from(\"estatisticas_areas\").insert({\n                    user_id: userId,\n                    cargo_id: cargoId,\n                    area_id: areaIdNum,\n                    total_questoes: total,\n                    acertos,\n                    percentual\n                });\n            }\n        }\n    }\n    embaralharArray(array) {\n        const embaralhado = [\n            ...array\n        ];\n        for(let i = embaralhado.length - 1; i > 0; i--){\n            const j = Math.floor(Math.random() * (i + 1));\n            [embaralhado[i], embaralhado[j]] = [\n                embaralhado[j],\n                embaralhado[i]\n            ];\n        }\n        return embaralhado;\n    }\n    constructor(){\n        this.supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcXVlc3RvZXNTZXJ2aWNlcy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlEQUFpRDtBQUNIO0FBc0I5QyxrQ0FBa0M7QUFDbEMsTUFBTUMsNEJBQTRCO0FBRTNCLE1BQU1DO0lBR1gsdUNBQXVDO0lBQ3ZDLE1BQWNDLGtCQUFvQztRQUNoRCxJQUFJO1lBQ0YsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNDLE9BQU87WUFDbEUsT0FBTyxDQUFDSCxTQUFTLENBQUMsQ0FBQ0Q7UUFDckIsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsT0FBTztRQUNUO0lBQ0Y7SUFDRixNQUFNSSxlQU1GO1FBQ0YsSUFBSTtZQUNGLE1BQU0sRUFBRU4sTUFBTU8sTUFBTSxFQUFFTCxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ0MsUUFBUSxDQUNoREssSUFBSSxDQUFDLFVBQ0xDLE1BQU0sQ0FBQyxrREFDUEMsRUFBRSxDQUFDLFNBQVMsTUFDWkMsS0FBSyxDQUFDO1lBRVQsSUFBSVQsT0FBTztnQkFDVFUsUUFBUVYsS0FBSyxDQUFDLDBCQUEwQkE7Z0JBQ3hDLE1BQU0sSUFBSVcsTUFBTVgsTUFBTVksT0FBTztZQUMvQjtZQUVBLE9BQU9QLFVBQVUsRUFBRTtRQUNyQixFQUFFLE9BQU9MLE9BQU87WUFDZFUsUUFBUVYsS0FBSyxDQUFDLDBCQUEwQkE7WUFDeEMsTUFBTUE7UUFDUjtJQUNGO0lBQ0UsTUFBTWEsdUJBQXVCQyxPQUFlLEVBSXpDO1FBQ0QsSUFBSSxDQUFDQSxTQUFTLE1BQU0sSUFBSUgsTUFBTTtRQUU5QixJQUFJO1lBQ0ZELFFBQVFLLEdBQUcsQ0FBQyxnQ0FBZ0NEO1lBRTVDLDhCQUE4QjtZQUM5QixNQUFNLEVBQUVoQixNQUFNa0IsUUFBUSxFQUFFaEIsT0FBT2lCLGFBQWEsRUFBRSxHQUFHLE1B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RyxFQUFFO1lBQ3JDLE9BQU87Z0JBQ0wsTUFBTXdCLGFBQWEsVUFBVy9CLFFBQVM7Z0JBRXZDLE1BQU0sSUFBSSxDQUFDbkIsUUFBUSxDQUNoQkssSUFBSSxDQUFDLHNCQUNMeUcsTUFBTSxDQUFDO29CQUNOQyxTQUFTZDtvQkFDVGUsVUFBVW5HO29CQUNWVyxTQUFTMkc7b0JBQ1RwRixnQkFBZ0I1QjtvQkFDaEI4QjtvQkFDQUM7Z0JBQ0Y7WUFDSjtRQUNGO0lBQ0Y7SUFFUXlCLGdCQUFtQmdFLEtBQVUsRUFBTztRQUMxQyxNQUFNQyxjQUFjO2VBQUlEO1NBQU07UUFDOUIsSUFBSyxJQUFJRSxJQUFJRCxZQUFZM0gsTUFBTSxHQUFHLEdBQUc0SCxJQUFJLEdBQUdBLElBQUs7WUFDL0MsTUFBTUMsSUFBSTdFLEtBQUtHLEtBQUssQ0FBQ0gsS0FBSzhFLE1BQU0sS0FBTUYsQ0FBQUEsSUFBSTtZQUMxQyxDQUFDRCxXQUFXLENBQUNDLEVBQUUsRUFBRUQsV0FBVyxDQUFDRSxFQUFFLENBQUMsR0FBRztnQkFBQ0YsV0FBVyxDQUFDRSxFQUFFO2dCQUFFRixXQUFXLENBQUNDLEVBQUU7YUFBQztRQUNyRTtRQUNBLE9BQU9EO0lBQ1Q7O2FBL25CUTVJLFdBQVdQLDJEQUFZQTs7QUFnb0JqQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3F1ZXN0b2VzU2VydmljZXMudHM/OThkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGliL3F1ZXN0b2VzU2VydmljZXMudHMgLSBWRVJTw4NPIENPUlJJR0lEQVxyXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XHJcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSAnQC9saWIvdHlwZXMnO1xyXG5cclxudHlwZSBRdWVzdGFvID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsncXVlc3RvZXMnXVsnUm93J107XHJcbnR5cGUgQXJlYSA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ2FyZWFzX2NvbmhlY2ltZW50byddWydSb3cnXTsgXHJcbnR5cGUgQ2FyZ29BcmVhID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsnY2FyZ29fYXJlYXMnXVsnUm93J107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXN0YW9Db21wbGV0YSBleHRlbmRzIFF1ZXN0YW8ge1xyXG4gIGFyZWFfbm9tZTogc3RyaW5nO1xyXG4gIHBlc29fYXJlYTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFyZWFFc3RhdGlzdGljYSB7XHJcbiAgaWQ6IG51bWJlcjtcclxuICBub21lOiBzdHJpbmc7XHJcbiAgdG90YWxfcXVlc3RvZXM6IG51bWJlcjtcclxuICBwZXNvOiBudW1iZXI7XHJcbiAgcXVlc3RvZXNfcmVzcG9uZGlkYXM6IG51bWJlcjtcclxuICBhY2VydG9zOiBudW1iZXI7XHJcbiAgcGVyY2VudHVhbDogbnVtYmVyO1xyXG59XHJcblxyXG4vLyBDT05GSUdVUkHDh8ODTyBETyBMSU1JVEUgR1JBVFVJVE9cclxuY29uc3QgTElNSVRFX1FVRVNUT0VTX0dSQVRVSVRBUyA9IDM7XHJcblxyXG5leHBvcnQgY2xhc3MgUXVlc3RvZXNTZXJ2aWNlIHtcclxuICBwcml2YXRlIHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCk7XHJcblxyXG4gIC8vIE3DqXRvZG8gYXV4aWxpYXIgcGFyYSB2ZXJpZmljYXIgbG9naW5cclxuICBwcml2YXRlIGFzeW5jIGlzVXN1YXJpb0xvZ2FkbygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xyXG4gICAgICByZXR1cm4gIWVycm9yICYmICEhdXNlcjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbmFzeW5jIGJ1c2NhckNhcmdvcygpOiBQcm9taXNlPEFycmF5PHtcclxuICBpZDogbnVtYmVyO1xyXG4gIG5vbWU6IHN0cmluZztcclxuICBkZXNjcmljYW86IHN0cmluZyB8IG51bGw7XHJcbiAgbml2ZWxfZXNjb2xhcmlkYWRlOiBzdHJpbmcgfCBudWxsO1xyXG4gIGJhbmNhOiBzdHJpbmcgfCBudWxsO1xyXG59Pj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IGNhcmdvcywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2NhcmdvcycpXHJcbiAgICAgIC5zZWxlY3QoJ2lkLCBub21lLCBkZXNjcmljYW8sIG5pdmVsX2VzY29sYXJpZGFkZSwgYmFuY2EnKVxyXG4gICAgICAuZXEoJ2F0aXZvJywgdHJ1ZSlcclxuICAgICAgLm9yZGVyKCdub21lJyk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gYnVzY2FyIGNhcmdvczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FyZ29zIHx8IFtdO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGJ1c2NhciBjYXJnb3M6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcbiAgYXN5bmMgYnVzY2FyUXVlc3RvZXNQb3JDYXJnbyhjYXJnb0lkOiBudW1iZXIpOiBQcm9taXNlPHtcclxuICAgIHF1ZXN0b2VzOiBRdWVzdGFvQ29tcGxldGFbXTtcclxuICAgIGFyZWFzOiBBcmVhRXN0YXRpc3RpY2FbXTtcclxuICAgIHRvdGFsOiBudW1iZXI7XHJcbiAgfT4ge1xyXG4gICAgaWYgKCFjYXJnb0lkKSB0aHJvdyBuZXcgRXJyb3IoJ2NhcmdvSWQgw6kgb2JyaWdhdMOzcmlvJyk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdJbmljaWFuZG8gYnVzY2EgcG9yIGNhcmdvSWQ6JywgY2FyZ29JZCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyAxLiBCdXNjYXIgVE9EQVMgYXMgcXVlc3TDtWVzXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogcXVlc3RvZXMsIGVycm9yOiBxdWVzdG9lc0Vycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3F1ZXN0b2VzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAuZXEoJ2NhcmdvX2lkJywgY2FyZ29JZClcclxuICAgICAgICAuZXEoJ2F0aXZvJywgdHJ1ZSlcclxuICAgICAgICAub3JkZXIoJ2FyZWFfaWQnKVxyXG4gICAgICAgIC5vcmRlcignaWQnKTtcclxuXHJcbiAgICAgIGlmIChxdWVzdG9lc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBuYSBxdWVyeSBkZSBxdWVzdMO1ZXM6JywgcXVlc3RvZXNFcnJvcik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHF1ZXN0b2VzRXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcXVlc3RvZXMgfHwgcXVlc3RvZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ05lbmh1bWEgcXVlc3TDo28gZW5jb250cmFkYSBwYXJhIG8gY2FyZ286JywgY2FyZ29JZCk7XHJcbiAgICAgICAgcmV0dXJuIHsgcXVlc3RvZXM6IFtdLCBhcmVhczogW10sIHRvdGFsOiAwIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBRdWVzdMO1ZXMgZW5jb250cmFkYXM6ICR7cXVlc3RvZXMubGVuZ3RofWApO1xyXG5cclxuICAgICAgLy8gMi4gQnVzY2FyIMOhcmVhcyAtIENPUlJJR0lETyAoZXZpdGEgcHJvYmxlbWEgY29tIC5pbigpKVxyXG4gICAgICBjb25zdCBhcmVhSWRzID0gWy4uLm5ldyBTZXQocXVlc3RvZXMubWFwKHEgPT4gcS5hcmVhX2lkKS5maWx0ZXIoaWQgPT4gaWQgIT09IG51bGwpKV07XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBcmVhIElEcyBhIGJ1c2NhcjonLCBhcmVhSWRzKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogYXJlYXMsIGVycm9yOiBhcmVhc0Vycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FyZWFzX2NvbmhlY2ltZW50bycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpO1xyXG5cclxuICAgICAgLy8gRmlsdHJhciBhcGVuYXMgYXMgw6FyZWFzIHF1ZSB0w6ptIHF1ZXN0w7Vlc1xyXG4gICAgICBjb25zdCBhcmVhc0NvbVF1ZXN0b2VzID0gYXJlYXM/LmZpbHRlcihhcmVhID0+IGFyZWFJZHMuaW5jbHVkZXMoYXJlYS5pZCkpIHx8IFtdO1xyXG5cclxuICAgICAgLy8gQURJQ0lPTkFSIHZlcmlmaWNhw6fDo28gZGUgZXJybzpcclxuICAgICAgaWYgKGFyZWFzRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGJ1c2NhciDDoXJlYXM6JywgYXJlYXNFcnJvcik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvIGFvIGJ1c2NhciDDoXJlYXM6ICR7YXJlYXNFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnVG9kYXMgYXMgw6FyZWFzIGRvIGJhbmNvOicsIGFyZWFzKTtcclxuICAgICAgY29uc29sZS5sb2coJ8OBcmVhcyBmaWx0cmFkYXMgY29tIHF1ZXN0w7VlczonLCBhcmVhc0NvbVF1ZXN0b2VzKTtcclxuXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogY2FyZ29BcmVhcywgZXJyb3I6IGNhcmdvQXJlYXNFcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjYXJnb19hcmVhcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCdjYXJnb19pZCcsIGNhcmdvSWQpO1xyXG5cclxuICAgICAgaWYgKGNhcmdvQXJlYXNFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRXJybyBhbyBidXNjYXIgY2FyZ29fYXJlYXM6JywgY2FyZ29BcmVhc0Vycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gMy4gQ3JpYXIgbWFwYXMgcGFyYSByZWxhY2lvbmFtZW50byAtIENPUlJJR0lET1xyXG4gICAgICBjb25zdCBhcmVhTWFwID0gKGFyZWFzICYmIGFyZWFzLmxlbmd0aCA+IDApID8gYXJlYXMucmVkdWNlKChhY2MsIGFyZWEpID0+IHtcclxuICAgICAgICBhY2NbYXJlYS5pZF0gPSBhcmVhLm5vbWU7XHJcbiAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgfSwge30gYXMgeyBba2V5OiBudW1iZXJdOiBzdHJpbmcgfSkgOiB7fTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdBcmVhIG1hcCBjcmlhZG86JywgYXJlYU1hcCk7XHJcblxyXG4gICAgICBjb25zdCBjYXJnb0FyZWFNYXAgPSBjYXJnb0FyZWFzPy5yZWR1Y2UoKGFjYywgY2EpID0+IHtcclxuICAgICAgICBhY2NbY2EuYXJlYV9pZCFdID0ge1xyXG4gICAgICAgICAgbnVtZXJvX3F1ZXN0b2VzOiBjYS5udW1lcm9fcXVlc3RvZXMsXHJcbiAgICAgICAgICBwZXNvOiBjYS5wZXNvIHx8IDEuMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgfSwge30gYXMgeyBba2V5OiBudW1iZXJdOiB7IG51bWVyb19xdWVzdG9lczogbnVtYmVyOyBwZXNvOiBudW1iZXIgfSB9KSB8fCB7fTtcclxuXHJcbiAgICAgIC8vIDQuIE1vbnRhciBxdWVzdMO1ZXMgY29tcGxldGFzIC0gQ09SUklHSURPXHJcbiAgICAgIGNvbnN0IHF1ZXN0b2VzQ29tcGxldGFzOiBRdWVzdGFvQ29tcGxldGFbXSA9IHF1ZXN0b2VzLm1hcChxID0+ICh7XHJcbiAgICAgICAgLi4ucSxcclxuICAgICAgICBhcmVhX25vbWU6IGFyZWFNYXBbcS5hcmVhX2lkIV0gfHwgJ8OBcmVhIERlc2NvbmhlY2lkYScsXHJcbiAgICAgICAgcGVzb19hcmVhOiBjYXJnb0FyZWFNYXBbcS5hcmVhX2lkIV0/LnBlc28gfHwgMS4wXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIC8vIDUuIE1vbnRhciBlc3RhdMOtc3RpY2FzIGRhcyDDoXJlYXMgLSBDT1JSSUdJRE9cclxuICAgICAgLy8gNS4gTW9udGFyIGVzdGF0w61zdGljYXMgZGFzIMOhcmVhcyAtIENPUlJJR0lET1xyXG5sZXQgYXJlYXNFc3RhdGlzdGljYXM6IEFyZWFFc3RhdGlzdGljYVtdO1xyXG5cclxuaWYgKGNhcmdvQXJlYXMgJiYgY2FyZ29BcmVhcy5sZW5ndGggPiAwKSB7XHJcbiAgYXJlYXNFc3RhdGlzdGljYXMgPSBjYXJnb0FyZWFzLm1hcChjYSA9PiB7XHJcbiAgICAvLyBDT05UQVIgUVVFU1TDlUVTIFJFQUlTIEVNIFZFWiBERSBVU0FSIFZBTE9SIEZJWE9cclxuICAgIGNvbnN0IHF1ZXN0b2VzRGFBcmVhID0gcXVlc3RvZXMuZmlsdGVyKHEgPT4gcS5hcmVhX2lkID09PSBjYS5hcmVhX2lkKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6IGNhLmFyZWFfaWQhLFxyXG4gICAgICBub21lOiBhcmVhTWFwW2NhLmFyZWFfaWQhXSB8fCAnw4FyZWEgRGVzY29uaGVjaWRhJyxcclxuICAgICAgdG90YWxfcXVlc3RvZXM6IHF1ZXN0b2VzRGFBcmVhLmxlbmd0aCwgLy8g4oaQIENPUlJFw4fDg086IHVzYXIgY29udGFnZW0gcmVhbFxyXG4gICAgICBwZXNvOiBjYS5wZXNvIHx8IDEuMCxcclxuICAgICAgcXVlc3RvZXNfcmVzcG9uZGlkYXM6IDAsXHJcbiAgICAgIGFjZXJ0b3M6IDAsXHJcbiAgICAgIHBlcmNlbnR1YWw6IDBcclxuICAgIH07XHJcbiAgfSk7XHJcbn0gZWxzZSB7XHJcbiAgYXJlYXNFc3RhdGlzdGljYXMgPSBhcmVhSWRzLm1hcChhcmVhSWQgPT4ge1xyXG4gICAgY29uc3QgcXVlc3RvZXNEYUFyZWEgPSBxdWVzdG9lcy5maWx0ZXIocSA9PiBxLmFyZWFfaWQgPT09IGFyZWFJZCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogYXJlYUlkISxcclxuICAgICAgbm9tZTogYXJlYU1hcFthcmVhSWQhXSB8fCAnw4FyZWEgRGVzY29uaGVjaWRhJyxcclxuICAgICAgdG90YWxfcXVlc3RvZXM6IHF1ZXN0b2VzRGFBcmVhLmxlbmd0aCxcclxuICAgICAgcGVzbzogMS4wLFxyXG4gICAgICBxdWVzdG9lc19yZXNwb25kaWRhczogMCxcclxuICAgICAgYWNlcnRvczogMCxcclxuICAgICAgcGVyY2VudHVhbDogMFxyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYEJ1c2NhIGNvbmNsdcOtZGE6ICR7cXVlc3RvZXNDb21wbGV0YXMubGVuZ3RofSBxdWVzdMO1ZXMsICR7YXJlYXNFc3RhdGlzdGljYXMubGVuZ3RofSDDoXJlYXNgKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcXVlc3RvZXM6IHF1ZXN0b2VzQ29tcGxldGFzLFxyXG4gICAgICAgIGFyZWFzOiBhcmVhc0VzdGF0aXN0aWNhcyxcclxuICAgICAgICB0b3RhbDogcXVlc3RvZXMubGVuZ3RoXHJcbiAgICAgIH07XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJybyBnZXJhbCBhbyBidXNjYXIgcXVlc3TDtWVzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXJhIHVtIHNpbXVsYWRvIHBlcnNvbmFsaXphZG8gYmFzZWFkbyBuYSBkaXN0cmlidWnDp8OjbyBwb3Igw6FyZWEgZSBkaWZpY3VsZGFkZVxyXG4gICAqL1xyXG4gIGFzeW5jIGdlcmFyU2ltdWxhZG9QZXJzb25hbGl6YWRvKFxyXG4gICAgY2FyZ29JZDogbnVtYmVyLCBcclxuICAgIGRpZmljdWxkYWRlczogbnVtYmVyW10gPSBbMSwgMiwgM10gLy8gTsOtdmVpcyBkZSBkaWZpY3VsZGFkZSBhIGluY2x1aXJcclxuICApOiBQcm9taXNlPFF1ZXN0YW9Db21wbGV0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnSW5pY2lhbmRvIGdlcmHDp8OjbyBkbyBzaW11bGFkbyBwYXJhIGNhcmdvOicsIGNhcmdvSWQsICdkaWZpY3VsZGFkZXM6JywgZGlmaWN1bGRhZGVzKTtcclxuICAgICAgXHJcbiAgICAgIC8vIDEuIEJ1c2NhciBUT0RBUyBhcyBxdWVzdMO1ZXMgZG8gY2FyZ28gY29tIGZpbHRybyBkZSBkaWZpY3VsZGFkZVxyXG4gICAgICBjb25zdCB7IGRhdGE6IHRvZGFzUXVlc3RvZXMsIGVycm9yOiBxdWVzdG9lc0Vycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3F1ZXN0b2VzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAuZXEoJ2NhcmdvX2lkJywgY2FyZ29JZClcclxuICAgICAgICAuZXEoJ2F0aXZvJywgdHJ1ZSlcclxuICAgICAgICAuaW4oJ2RpZmljdWxkYWRlJywgZGlmaWN1bGRhZGVzKTtcclxuXHJcbiAgICAgIGlmIChxdWVzdG9lc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBidXNjYXIgcXVlc3TDtWVzOicsIHF1ZXN0b2VzRXJyb3IpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihxdWVzdG9lc0Vycm9yLm1lc3NhZ2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRvZGFzUXVlc3RvZXMgfHwgdG9kYXNRdWVzdG9lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05lbmh1bWEgcXVlc3TDo28gZW5jb250cmFkYSBwYXJhIG8gY2FyZ28gZSBkaWZpY3VsZGFkZXMgZXNwZWNpZmljYWRhcycpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYFRvdGFsIGRlIHF1ZXN0w7VlcyBkaXNwb27DrXZlaXM6ICR7dG9kYXNRdWVzdG9lcy5sZW5ndGh9YCk7XHJcblxyXG4gICAgICAvLyAyLiBCdXNjYXIgY29uZmlndXJhw6fDo28gZGUgY2FyZ29fYXJlYXNcclxuICAgICAgY29uc3QgeyBkYXRhOiBjYXJnb0FyZWFzLCBlcnJvcjogY29uZmlnRXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2FyZ29fYXJlYXMnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2FyZWFfaWQsIG51bWVyb19xdWVzdG9lcycpXHJcbiAgICAgICAgLmVxKCdjYXJnb19pZCcsIGNhcmdvSWQpO1xyXG5cclxuICAgICAgaWYgKGNvbmZpZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBidXNjYXIgY29uZmlndXJhw6fDo286JywgY29uZmlnRXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgQ29uZmlndXJhw6fDtWVzIGVuY29udHJhZGFzOiAke2NhcmdvQXJlYXM/Lmxlbmd0aCB8fCAwfWApO1xyXG5cclxuICAgICAgLy8gMy4gQnVzY2FyIGRhZG9zIGNvbXBsZW1lbnRhcmVzIHBhcmEgcXVlc3TDtWVzIGNvbXBsZXRhcyAtIENPUlJJR0lET1xyXG4gICAgICBjb25zdCBhcmVhSWRzID0gWy4uLm5ldyBTZXQodG9kYXNRdWVzdG9lcy5tYXAocSA9PiBxLmFyZWFfaWQpLmZpbHRlcihpZCA9PiBpZCAhPT0gbnVsbCkpXTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogYXJlYXMsIGVycm9yOiBhcmVhc0Vycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FyZWFzX2NvbmhlY2ltZW50bycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpO1xyXG5cclxuICAgICAgLy8gRmlsdHJhciBhcGVuYXMgYXMgw6FyZWFzIG5lY2Vzc8Ohcmlhc1xyXG4gICAgICBjb25zdCBhcmVhc0NvbVF1ZXN0b2VzID0gYXJlYXM/LmZpbHRlcihhcmVhID0+IGFyZWFJZHMuaW5jbHVkZXMoYXJlYS5pZCkpIHx8IFtdO1xyXG5cclxuICAgICAgaWYgKGFyZWFzRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGJ1c2NhciDDoXJlYXMgcGFyYSBzaW11bGFkbzonLCBhcmVhc0Vycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgeyBkYXRhOiBjb25maWdBcmVhcyB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjYXJnb19hcmVhcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCdjYXJnb19pZCcsIGNhcmdvSWQpO1xyXG5cclxuICAgICAgLy8gQ3JpYXIgbWFwYXMgLSBDT1JSSUdJRE9cclxuICAgICAgY29uc3QgYXJlYU1hcCA9IChhcmVhc0NvbVF1ZXN0b2VzICYmIGFyZWFzQ29tUXVlc3RvZXMubGVuZ3RoID4gMCkgPyBhcmVhc0NvbVF1ZXN0b2VzLnJlZHVjZSgoYWNjLCBhcmVhKSA9PiB7XHJcbiAgICAgICAgYWNjW2FyZWEuaWRdID0gYXJlYS5ub21lO1xyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgIH0sIHt9IGFzIHsgW2tleTogbnVtYmVyXTogc3RyaW5nIH0pIDoge307XHJcblxyXG4gICAgICBjb25zdCBwZXNvTWFwID0gY29uZmlnQXJlYXM/LnJlZHVjZSgoYWNjLCBjb25maWcpID0+IHtcclxuICAgICAgICBhY2NbY29uZmlnLmFyZWFfaWQhXSA9IGNvbmZpZy5wZXNvIHx8IDEuMDtcclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9LCB7fSBhcyB7IFtrZXk6IG51bWJlcl06IG51bWJlciB9KSB8fCB7fTtcclxuXHJcbiAgICAgIC8vIE1vbnRhciBxdWVzdMO1ZXMgY29tcGxldGFzIC0gQ09SUklHSURPXHJcbiAgICAgIGNvbnN0IHF1ZXN0b2VzQ29tcGxldGFzOiBRdWVzdGFvQ29tcGxldGFbXSA9IHRvZGFzUXVlc3RvZXMubWFwKHEgPT4gKHtcclxuICAgICAgICAuLi5xLFxyXG4gICAgICAgIGFyZWFfbm9tZTogYXJlYU1hcFtxLmFyZWFfaWQhXSB8fCAnw4FyZWEgRGVzY29uaGVjaWRhJyxcclxuICAgICAgICBwZXNvX2FyZWE6IHBlc29NYXBbcS5hcmVhX2lkIV0gfHwgMS4wXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGxldCBxdWVzdG9lc1NpbXVsYWRvOiBRdWVzdGFvQ29tcGxldGFbXSA9IFtdO1xyXG5cclxuICAgICAgLy8gNC4gU2UgbsOjbyBow6EgY29uZmlndXJhw6fDo28sIHVzYXIgZGlzdHJpYnVpw6fDo28gc2ltcGxlcyBjb20gbWlzdHVyYSBkZSBkaWZpY3VsZGFkZXNcclxuICAgICAgaWYgKCFjYXJnb0FyZWFzIHx8IGNhcmdvQXJlYXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1NlbSBjb25maWd1cmHDp8OjbyBlc3BlY8OtZmljYSwgbWlzdHVyYW5kbyBxdWVzdMO1ZXMgcG9yIGRpZmljdWxkYWRlJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2VwYXJhciBxdWVzdMO1ZXMgcG9yIGRpZmljdWxkYWRlXHJcbiAgICAgICAgY29uc3QgcXVlc3RvZXNQb3JEaWZpY3VsZGFkZSA9IGRpZmljdWxkYWRlcy5yZWR1Y2UoKGFjYywgbml2ZWwpID0+IHtcclxuICAgICAgICAgIGFjY1tuaXZlbF0gPSBxdWVzdG9lc0NvbXBsZXRhcy5maWx0ZXIocSA9PiBxLmRpZmljdWxkYWRlID09PSBuaXZlbCk7XHJcbiAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIH0sIHt9IGFzIHsgW2tleTogbnVtYmVyXTogUXVlc3Rhb0NvbXBsZXRhW10gfSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGFyIHF1YW50YXMgcXVlc3TDtWVzIGRlIGNhZGEgZGlmaWN1bGRhZGUgaW5jbHVpclxyXG4gICAgICAgIGNvbnN0IHRvdGFsRGVzZWphZG8gPSBNYXRoLm1pbigxMjAsIHF1ZXN0b2VzQ29tcGxldGFzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgcXVlc3RvZXNQb3JOaXZlbCA9IE1hdGguZmxvb3IodG90YWxEZXNlamFkbyAvIGRpZmljdWxkYWRlcy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3RvID0gdG90YWxEZXNlamFkbyAlIGRpZmljdWxkYWRlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGRpZmljdWxkYWRlcy5mb3JFYWNoKChuaXZlbCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHF1YW50aWRhZGUgPSBxdWVzdG9lc1Bvck5pdmVsICsgKGluZGV4IDwgcmVzdG8gPyAxIDogMCk7XHJcbiAgICAgICAgICBjb25zdCBkaXNwb27DrXZlaXMgPSBxdWVzdG9lc1BvckRpZmljdWxkYWRlW25pdmVsXSB8fCBbXTtcclxuICAgICAgICAgIGNvbnN0IGVtYmFyYWxoYWRhcyA9IHRoaXMuZW1iYXJhbGhhckFycmF5KGRpc3BvbsOtdmVpcyk7XHJcbiAgICAgICAgICBxdWVzdG9lc1NpbXVsYWRvLnB1c2goLi4uZW1iYXJhbGhhZGFzLnNsaWNlKDAsIHF1YW50aWRhZGUpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcXVlc3RvZXNTaW11bGFkbyA9IHRoaXMuZW1iYXJhbGhhckFycmF5KHF1ZXN0b2VzU2ltdWxhZG8pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIDUuIFVzYXIgY29uZmlndXJhw6fDo28gZXNwZWPDrWZpY2EgcG9yIMOhcmVhLCBtaXN0dXJhbmRvIGRpZmljdWxkYWRlcyBkZW50cm8gZGUgY2FkYSDDoXJlYVxyXG4gICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNhcmdvQXJlYXMpIHtcclxuICAgICAgICAgIGNvbnN0IHF1ZXN0b2VzRGFBcmVhID0gcXVlc3RvZXNDb21wbGV0YXMuZmlsdGVyKHEgPT4gcS5hcmVhX2lkID09PSBjb25maWcuYXJlYV9pZCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgw4FyZWEgJHtjb25maWcuYXJlYV9pZH06ICR7cXVlc3RvZXNEYUFyZWEubGVuZ3RofSBxdWVzdMO1ZXMgZGlzcG9uw612ZWlzLCAke2NvbmZpZy5udW1lcm9fcXVlc3RvZXN9IHNvbGljaXRhZGFzYCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChxdWVzdG9lc0RhQXJlYS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIFNlcGFyYXIgcG9yIGRpZmljdWxkYWRlIGRlbnRybyBkYSDDoXJlYVxyXG4gICAgICAgICAgICBjb25zdCBxdWVzdG9lc1BvckRpZmljdWxkYWRlID0gZGlmaWN1bGRhZGVzLnJlZHVjZSgoYWNjLCBuaXZlbCkgPT4ge1xyXG4gICAgICAgICAgICAgIGFjY1tuaXZlbF0gPSBxdWVzdG9lc0RhQXJlYS5maWx0ZXIocSA9PiBxLmRpZmljdWxkYWRlID09PSBuaXZlbCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICAgICAgfSwge30gYXMgeyBba2V5OiBudW1iZXJdOiBRdWVzdGFvQ29tcGxldGFbXSB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc3RyaWJ1aXIgcXVlc3TDtWVzIGRhIMOhcmVhIHByb3BvcmNpb25hbG1lbnRlIGVudHJlIGRpZmljdWxkYWRlc1xyXG4gICAgICAgICAgICBjb25zdCBxdWVzdG9lc0RhQXJlYVNlbGVjaW9uYWRhczogUXVlc3Rhb0NvbXBsZXRhW10gPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgcXVlc3RvZXNQb3JOaXZlbCA9IE1hdGguZmxvb3IoY29uZmlnLm51bWVyb19xdWVzdG9lcyAvIGRpZmljdWxkYWRlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN0byA9IGNvbmZpZy5udW1lcm9fcXVlc3RvZXMgJSBkaWZpY3VsZGFkZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgZGlmaWN1bGRhZGVzLmZvckVhY2goKG5pdmVsLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHF1YW50aWRhZGUgPSBxdWVzdG9lc1Bvck5pdmVsICsgKGluZGV4IDwgcmVzdG8gPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgZGlzcG9uw612ZWlzID0gcXVlc3RvZXNQb3JEaWZpY3VsZGFkZVtuaXZlbF0gfHwgW107XHJcbiAgICAgICAgICAgICAgY29uc3QgZW1iYXJhbGhhZGFzID0gdGhpcy5lbWJhcmFsaGFyQXJyYXkoZGlzcG9uw612ZWlzKTtcclxuICAgICAgICAgICAgICBxdWVzdG9lc0RhQXJlYVNlbGVjaW9uYWRhcy5wdXNoKC4uLmVtYmFyYWxoYWRhcy5zbGljZSgwLCBxdWFudGlkYWRlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcXVlc3RvZXNTaW11bGFkby5wdXNoKC4uLnF1ZXN0b2VzRGFBcmVhU2VsZWNpb25hZGFzKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFNlbGVjaW9uYWRhcyAke3F1ZXN0b2VzRGFBcmVhU2VsZWNpb25hZGFzLmxlbmd0aH0gcXVlc3TDtWVzIGRhIMOhcmVhICR7Y29uZmlnLmFyZWFfaWR9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxdWVzdG9lc1NpbXVsYWRvID0gdGhpcy5lbWJhcmFsaGFyQXJyYXkocXVlc3RvZXNTaW11bGFkbyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNpbXVsYWRvRmluYWwgPSBxdWVzdG9lc1NpbXVsYWRvO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYFNpbXVsYWRvIGZpbmFsIGdlcmFkbzogJHtzaW11bGFkb0ZpbmFsLmxlbmd0aH0gcXVlc3TDtWVzYCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEaXN0cmlidWnDp8OjbyBwb3Igw6FyZWE6JywgXHJcbiAgICAgICAgc2ltdWxhZG9GaW5hbC5yZWR1Y2UoKGFjYywgcSkgPT4ge1xyXG4gICAgICAgICAgYWNjW3EuYXJlYV9ub21lXSA9IChhY2NbcS5hcmVhX25vbWVdIHx8IDApICsgMTtcclxuICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPilcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBzaW11bGFkb0ZpbmFsO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gZ2VyYXIgc2ltdWxhZG86JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE3DqXRvZG8gcGFyYSB2ZXJpZmljYXIgc2UgdXN1w6FyaW8gZGV2ZSB2ZXIgbW9kYWxcclxuICBhc3luYyBkZXZlRXhpYmlyTW9kYWxMb2dpbihxdWVzdG9lc1Jlc3BvbmRpZGFzOiBudW1iZXIpOiBQcm9taXNlPHtcclxuICAgIGV4aWJpck1vZGFsOiBib29sZWFuO1xyXG4gICAgYmVuZWZpY2lvczogc3RyaW5nW107XHJcbiAgICBxdWVzdG9lc1RvdGFpczogbnVtYmVyO1xyXG4gICAgcXVlc3RvZXNMaWJlcmFkYXM6IG51bWJlcjtcclxuICB9PiB7XHJcbiAgICBjb25zdCBpc0xvZ2FkbyA9IGF3YWl0IHRoaXMuaXNVc3VhcmlvTG9nYWRvKCk7XHJcbiAgICBcclxuICAgIGlmIChpc0xvZ2FkbyB8fCBxdWVzdG9lc1Jlc3BvbmRpZGFzIDwgTElNSVRFX1FVRVNUT0VTX0dSQVRVSVRBUykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4aWJpck1vZGFsOiBmYWxzZSxcclxuICAgICAgICBiZW5lZmljaW9zOiBbXSxcclxuICAgICAgICBxdWVzdG9lc1RvdGFpczogMCxcclxuICAgICAgICBxdWVzdG9lc0xpYmVyYWRhczogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGV4aWJpck1vZGFsOiB0cnVlLFxyXG4gICAgICBiZW5lZmljaW9zOiBbXHJcbiAgICAgICAgXCJBY2Vzc28gY29tcGxldG8gYSB0b2RhcyBhcyBxdWVzdMO1ZXMgZG8gc2ltdWxhZG9cIixcclxuICAgICAgICBcIlJlbGF0w7NyaW9zIGRldGFsaGFkb3MgZGUgZGVzZW1wZW5obyBwb3Igw6FyZWFcIixcclxuICAgICAgICBcIkNyb27DtG1ldHJvIGUgY29udHJvbGUgZGUgdGVtcG8gcGVyc29uYWxpemFkb1wiLFxyXG4gICAgICAgIFwiQWNvbXBhbmhhbWVudG8gZGUgZXZvbHXDp8OjbyBlIGVzdGF0w61zdGljYXNcIixcclxuICAgICAgICBcIkhpc3TDs3JpY28gY29tcGxldG8gZGUgc2ltdWxhZG9zIHJlYWxpemFkb3NcIixcclxuICAgICAgICBcIlF1ZXN0w7VlcyBzZW1wcmUgYXR1YWxpemFkYXMgY29uZm9ybWUgbyBlZGl0YWxcIixcclxuICAgICAgICBcIlNpbmNyb25pemHDp8OjbyBlbnRyZSBkaXNwb3NpdGl2b3NcIixcclxuICAgICAgICBcIkNvbWVudMOhcmlvcyBkZXRhbGhhZG9zIGNvbSBleHBsaWNhw6fDtWVzIGRhcyByZWdyYXNcIlxyXG4gICAgICBdLFxyXG4gICAgICBxdWVzdG9lc1RvdGFpczogMCxcclxuICAgICAgcXVlc3RvZXNMaWJlcmFkYXM6IExJTUlURV9RVUVTVE9FU19HUkFUVUlUQVNcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyB0ZXN0YXJDb25leGFvKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rlc3RhbmRvIGNvbmV4w6NvIGNvbSBTdXBhYmFzZS4uLicpO1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3F1ZXN0b2VzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCcpXHJcbiAgICAgICAgLmxpbWl0KDEpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBkZSBjb25leMOjbzonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdDb25leMOjbyBiZW0tc3VjZWRpZGEnKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGdlcmFsIG5hIGNvbmV4w6NvOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdXNjYSBxdWVzdMO1ZXMgZGUgdW1hIMOhcmVhIGVzcGVjw61maWNhXHJcbiAgICovXHJcbiAgYXN5bmMgYnVzY2FyUXVlc3RvZXNQb3JBcmVhKGNhcmdvSWQ6IG51bWJlciwgYXJlYUlkOiBudW1iZXIsIGxpbWl0ZT86IG51bWJlcik6IFByb21pc2U8UXVlc3Rhb0NvbXBsZXRhW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCBxdWVzdG9lc1F1ZXJ5ID0gdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdxdWVzdG9lcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCdjYXJnb19pZCcsIGNhcmdvSWQpXHJcbiAgICAgICAgLmVxKCdhcmVhX2lkJywgYXJlYUlkKVxyXG4gICAgICAgIC5lcSgnYXRpdm8nLCB0cnVlKVxyXG4gICAgICAgIC5vcmRlcignaWQnKTtcclxuXHJcbiAgICAgIGlmIChsaW1pdGUpIHtcclxuICAgICAgICBxdWVzdG9lc1F1ZXJ5ID0gcXVlc3RvZXNRdWVyeS5saW1pdChsaW1pdGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB7IGRhdGE6IHF1ZXN0b2VzLCBlcnJvcjogcXVlc3RvZXNFcnJvciB9ID0gYXdhaXQgcXVlc3RvZXNRdWVyeTtcclxuICAgICAgaWYgKHF1ZXN0b2VzRXJyb3IpIHRocm93IG5ldyBFcnJvcihxdWVzdG9lc0Vycm9yLm1lc3NhZ2UpO1xyXG5cclxuICAgICAgaWYgKCFxdWVzdG9lcyB8fCBxdWVzdG9lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJ1c2NhciBub21lIGRhIMOhcmVhIC0gQ09SUklHSURPXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogYXJlYSwgZXJyb3I6IGFyZWFFcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdhcmVhc19jb25oZWNpbWVudG8nKVxyXG4gICAgICAgIC5zZWxlY3QoJ25vbWUnKVxyXG4gICAgICAgIC5lcSgnaWQnLCBhcmVhSWQpXHJcbiAgICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgICAgaWYgKGFyZWFFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRXJybyBhbyBidXNjYXIgbm9tZSBkYSDDoXJlYTonLCBhcmVhRXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBCdXNjYXIgcGVzbyBkYSDDoXJlYVxyXG4gICAgICBjb25zdCB7IGRhdGE6IGNhcmdvQXJlYSwgZXJyb3I6IGNhcmdvQXJlYUVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2NhcmdvX2FyZWFzJylcclxuICAgICAgICAuc2VsZWN0KCdwZXNvJylcclxuICAgICAgICAuZXEoJ2NhcmdvX2lkJywgY2FyZ29JZClcclxuICAgICAgICAuZXEoJ2FyZWFfaWQnLCBhcmVhSWQpXHJcbiAgICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgICAgaWYgKGNhcmdvQXJlYUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdFcnJvIGFvIGJ1c2NhciBjb25maWd1cmHDp8OjbyBkYSDDoXJlYTonLCBjYXJnb0FyZWFFcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1vbnRhciBxdWVzdMO1ZXMgY29tcGxldGFzIC0gQ09SUklHSURPXHJcbiAgICAgIGNvbnN0IHF1ZXN0b2VzQ29tcGxldGFzOiBRdWVzdGFvQ29tcGxldGFbXSA9IHF1ZXN0b2VzLm1hcChxID0+ICh7XHJcbiAgICAgICAgLi4ucSxcclxuICAgICAgICBhcmVhX25vbWU6IGFyZWE/Lm5vbWUgfHwgJ8OBcmVhIERlc2NvbmhlY2lkYScsXHJcbiAgICAgICAgcGVzb19hcmVhOiBjYXJnb0FyZWE/LnBlc28gfHwgMS4wXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHJldHVybiBxdWVzdG9lc0NvbXBsZXRhcztcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGJ1c2NhciBxdWVzdMO1ZXMgcG9yIMOhcmVhOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdXNjYSBlc3RhdMOtc3RpY2FzIGRlIGRlc2VtcGVuaG8gcG9yIMOhcmVhIHBhcmEgdW0gdXN1w6FyaW9cclxuICAgKi9cclxuICBhc3luYyBidXNjYXJFc3RhdGlzdGljYXNVc3VhcmlvKHVzZXJJZDogc3RyaW5nLCBjYXJnb0lkOiBudW1iZXIpOiBQcm9taXNlPEFyZWFFc3RhdGlzdGljYVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBCdXNjYXIgZXN0YXTDrXN0aWNhc1xyXG4gICAgICBjb25zdCB7IGRhdGE6IHN0YXRzLCBlcnJvcjogc3RhdHNFcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdlc3RhdGlzdGljYXNfYXJlYXMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcclxuICAgICAgICAuZXEoJ2NhcmdvX2lkJywgY2FyZ29JZCk7XHJcblxyXG4gICAgICBpZiAoc3RhdHNFcnJvcikgdGhyb3cgbmV3IEVycm9yKHN0YXRzRXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIGlmICghc3RhdHMgfHwgc3RhdHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XHJcblxyXG4gICAgICAvLyBCdXNjYXIgbm9tZXMgZGFzIMOhcmVhcyAtIENPUlJJR0lET1xyXG4gICAgICBjb25zdCBhcmVhSWRzID0gc3RhdHMubWFwKHMgPT4gcy5hcmVhX2lkKS5maWx0ZXIoaWQgPT4gaWQgIT09IG51bGwpO1xyXG4gICAgICBjb25zdCB7IGRhdGE6IGFyZWFzLCBlcnJvcjogYXJlYXNFcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdhcmVhc19jb25oZWNpbWVudG8nKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5pbignaWQnLCBhcmVhSWRzKTtcclxuXHJcbiAgICAgIGlmIChhcmVhc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdFcnJvIGFvIGJ1c2NhciDDoXJlYXM6JywgYXJlYXNFcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJ1c2NhciBwZXNvcyBkYXMgw6FyZWFzXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogY2FyZ29BcmVhcywgZXJyb3I6IGNhcmdvQXJlYXNFcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjYXJnb19hcmVhcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCdjYXJnb19pZCcsIGNhcmdvSWQpXHJcbiAgICAgICAgLmluKCdhcmVhX2lkJywgYXJlYUlkcyk7XHJcblxyXG4gICAgICBpZiAoY2FyZ29BcmVhc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdFcnJvIGFvIGJ1c2NhciBjb25maWd1cmHDp8OjbyBkYXMgw6FyZWFzOicsIGNhcmdvQXJlYXNFcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENyaWFyIG1hcGFzIC0gQ09SUklHSURPXHJcbiAgICAgIGNvbnN0IGFyZWFNYXAgPSAoYXJlYXMgJiYgYXJlYXMubGVuZ3RoID4gMCkgPyBhcmVhcy5yZWR1Y2UoKGFjYywgYXJlYSkgPT4ge1xyXG4gICAgICAgIGFjY1thcmVhLmlkXSA9IGFyZWEubm9tZTtcclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9LCB7fSBhcyB7IFtrZXk6IG51bWJlcl06IHN0cmluZyB9KSA6IHt9O1xyXG5cclxuICAgICAgY29uc3QgcGVzb01hcCA9IGNhcmdvQXJlYXM/LnJlZHVjZSgoYWNjLCBjb25maWcpID0+IHtcclxuICAgICAgICBhY2NbY29uZmlnLmFyZWFfaWQhXSA9IGNvbmZpZy5wZXNvIHx8IDEuMDtcclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9LCB7fSBhcyB7IFtrZXk6IG51bWJlcl06IG51bWJlciB9KSB8fCB7fTtcclxuXHJcbiAgICAgIC8vIE1vbnRhciBlc3RhdMOtc3RpY2FzIC0gQ09SUklHSURPXHJcbiAgICAgIHJldHVybiBzdGF0cy5tYXAocyA9PiAoe1xyXG4gICAgICAgIGlkOiBzLmFyZWFfaWQhLFxyXG4gICAgICAgIG5vbWU6IGFyZWFNYXBbcy5hcmVhX2lkIV0gfHwgJ8OBcmVhIERlc2NvbmhlY2lkYScsXHJcbiAgICAgICAgdG90YWxfcXVlc3RvZXM6IHMudG90YWxfcXVlc3RvZXMgfHwgMCxcclxuICAgICAgICBwZXNvOiBwZXNvTWFwW3MuYXJlYV9pZCFdIHx8IDEuMCxcclxuICAgICAgICBxdWVzdG9lc19yZXNwb25kaWRhczogcy50b3RhbF9xdWVzdG9lcyB8fCAwLFxyXG4gICAgICAgIGFjZXJ0b3M6IHMuYWNlcnRvcyB8fCAwLFxyXG4gICAgICAgIHBlcmNlbnR1YWw6IHMucGVyY2VudHVhbCB8fCAwXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGJ1c2NhciBlc3RhdMOtc3RpY2FzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYWx2YSByZXN1bHRhZG8gZGUgc2ltdWxhZG9cclxuICAgKi9cclxuICBhc3luYyBzYWx2YXJSZXN1bHRhZG9TaW11bGFkbyhcclxuICAgIHVzZXJJZDogc3RyaW5nLFxyXG4gICAgY2FyZ29JZDogbnVtYmVyLFxyXG4gICAgcXVlc3RvZXM6IFF1ZXN0YW9Db21wbGV0YVtdLFxyXG4gICAgcmVzcG9zdGFzOiB7IFtrZXk6IG51bWJlcl06IHN0cmluZyB9LFxyXG4gICAgdGVtcG9HYXN0bzogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgcG9udHVhY2FvVG90YWwgPSAwO1xyXG4gICAgICBsZXQgcGVzb1RvdGFsID0gMDtcclxuICAgICAgbGV0IGFjZXJ0b3MgPSAwO1xyXG5cclxuICAgICAgcXVlc3RvZXMuZm9yRWFjaChxID0+IHtcclxuICAgICAgICBwZXNvVG90YWwgKz0gcS5wZXNvX2FyZWE7XHJcbiAgICAgICAgaWYgKHJlc3Bvc3Rhc1txLmlkXSA9PT0gcS5yZXNwb3N0YV9jb3JyZXRhKSB7XHJcbiAgICAgICAgICBhY2VydG9zKys7XHJcbiAgICAgICAgICBwb250dWFjYW9Ub3RhbCArPSBxLnBlc29fYXJlYTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgcGVyY2VudHVhbEFjZXJ0b3MgPSAoYWNlcnRvcyAvIHF1ZXN0b2VzLmxlbmd0aCkgKiAxMDA7XHJcblxyXG4gICAgICBjb25zdCB7IGRhdGE6IHNpbXVsYWRvLCBlcnJvcjogc2ltdWxhZG9FcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdzaW11bGFkb3MnKVxyXG4gICAgICAgIC5pbnNlcnQoe1xyXG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxyXG4gICAgICAgICAgY2FyZ29faWQ6IGNhcmdvSWQsXHJcbiAgICAgICAgICB0aXBvOiAncGVyc29uYWxpemFkbycsXHJcbiAgICAgICAgICBzdGF0dXM6ICdjb25jbHVpZG8nLFxyXG4gICAgICAgICAgZGF0YV9jb25jbHVzYW86IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIHRlbXBvX2dhc3RvOiB0ZW1wb0dhc3RvLFxyXG4gICAgICAgICAgcG9udHVhY2FvX3RvdGFsOiBwb250dWFjYW9Ub3RhbCxcclxuICAgICAgICAgIHBlcmNlbnR1YWxfYWNlcnRvczogcGVyY2VudHVhbEFjZXJ0b3NcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zZWxlY3QoJ2lkJylcclxuICAgICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgICBpZiAoc2ltdWxhZG9FcnJvcikgdGhyb3cgbmV3IEVycm9yKHNpbXVsYWRvRXJyb3IubWVzc2FnZSk7XHJcblxyXG4gICAgICBjb25zdCBxdWVzdG9lc1NpbXVsYWRvID0gcXVlc3RvZXMubWFwKChxLCBpbmRleCkgPT4gKHtcclxuICAgICAgICBzaW11bGFkb19pZDogc2ltdWxhZG8uaWQsXHJcbiAgICAgICAgcXVlc3Rhb19pZDogcS5pZCxcclxuICAgICAgICBvcmRlbTogaW5kZXggKyAxLFxyXG4gICAgICAgIHJlc3Bvc3RhX3VzdWFyaW86IHJlc3Bvc3Rhc1txLmlkXSB8fCBudWxsLFxyXG4gICAgICAgIGNvcnJldGE6IHJlc3Bvc3Rhc1txLmlkXSA9PT0gcS5yZXNwb3N0YV9jb3JyZXRhLFxyXG4gICAgICAgIHRlbXBvX3Jlc3Bvc3RhOiBNYXRoLmZsb29yKHRlbXBvR2FzdG8gLyBxdWVzdG9lcy5sZW5ndGgpXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHF1ZXN0b2VzRXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnc2ltdWxhZG9fcXVlc3RvZXMnKVxyXG4gICAgICAgIC5pbnNlcnQocXVlc3RvZXNTaW11bGFkbyk7XHJcblxyXG4gICAgICBpZiAocXVlc3RvZXNFcnJvcikgdGhyb3cgbmV3IEVycm9yKHF1ZXN0b2VzRXJyb3IubWVzc2FnZSk7XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLmF0dWFsaXphckVzdGF0aXN0aWNhc0FyZWFzKHVzZXJJZCwgY2FyZ29JZCwgcXVlc3RvZXMsIHJlc3Bvc3Rhcyk7XHJcblxyXG4gICAgICByZXR1cm4gc2ltdWxhZG8uaWQ7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHNhbHZhciByZXN1bHRhZG86JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dWFsaXphIGVzdGF0w61zdGljYXMgcG9yIMOhcmVhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBhdHVhbGl6YXJFc3RhdGlzdGljYXNBcmVhcyhcclxuICAgIHVzZXJJZDogc3RyaW5nLFxyXG4gICAgY2FyZ29JZDogbnVtYmVyLFxyXG4gICAgcXVlc3RvZXM6IFF1ZXN0YW9Db21wbGV0YVtdLFxyXG4gICAgcmVzcG9zdGFzOiB7IFtrZXk6IG51bWJlcl06IHN0cmluZyB9XHJcbiAgKSB7XHJcbiAgICBjb25zdCBxdWVzdG9lc1BvckFyZWEgPSBxdWVzdG9lcy5yZWR1Y2UoKGFjYywgcSkgPT4ge1xyXG4gICAgICBpZiAoIWFjY1txLmFyZWFfaWQhXSkge1xyXG4gICAgICAgIGFjY1txLmFyZWFfaWQhXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGFjY1txLmFyZWFfaWQhXS5wdXNoKHEpO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30gYXMgeyBba2V5OiBudW1iZXJdOiBRdWVzdGFvQ29tcGxldGFbXSB9KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFthcmVhSWQsIHF1ZXN0b2VzRGFBcmVhXSBvZiBPYmplY3QuZW50cmllcyhxdWVzdG9lc1BvckFyZWEpKSB7XHJcbiAgICAgIGNvbnN0IGFyZWFJZE51bSA9IHBhcnNlSW50KGFyZWFJZCk7XHJcbiAgICAgIGNvbnN0IGFjZXJ0b3MgPSBxdWVzdG9lc0RhQXJlYS5maWx0ZXIocSA9PiByZXNwb3N0YXNbcS5pZF0gPT09IHEucmVzcG9zdGFfY29ycmV0YSkubGVuZ3RoO1xyXG4gICAgICBjb25zdCB0b3RhbCA9IHF1ZXN0b2VzRGFBcmVhLmxlbmd0aDtcclxuXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogZXN0YXRpc3RpY2FFeGlzdGVudGUgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnZXN0YXRpc3RpY2FzX2FyZWFzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXHJcbiAgICAgICAgLmVxKCdjYXJnb19pZCcsIGNhcmdvSWQpXHJcbiAgICAgICAgLmVxKCdhcmVhX2lkJywgYXJlYUlkTnVtKVxyXG4gICAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICAgIGlmIChlc3RhdGlzdGljYUV4aXN0ZW50ZSkge1xyXG4gICAgICAgIGNvbnN0IG5vdm9Ub3RhbCA9IChlc3RhdGlzdGljYUV4aXN0ZW50ZS50b3RhbF9xdWVzdG9lcyB8fCAwKSArIHRvdGFsO1xyXG4gICAgICAgIGNvbnN0IG5vdm9zQWNlcnRvcyA9IChlc3RhdGlzdGljYUV4aXN0ZW50ZS5hY2VydG9zIHx8IDApICsgYWNlcnRvcztcclxuICAgICAgICBjb25zdCBub3ZvUGVyY2VudHVhbCA9IChub3Zvc0FjZXJ0b3MgLyBub3ZvVG90YWwpICogMTAwO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnZXN0YXRpc3RpY2FzX2FyZWFzJylcclxuICAgICAgICAgIC51cGRhdGUoe1xyXG4gICAgICAgICAgICB0b3RhbF9xdWVzdG9lczogbm92b1RvdGFsLFxyXG4gICAgICAgICAgICBhY2VydG9zOiBub3Zvc0FjZXJ0b3MsXHJcbiAgICAgICAgICAgIHBlcmNlbnR1YWw6IG5vdm9QZXJjZW50dWFsLFxyXG4gICAgICAgICAgICB1bHRpbWFfYXR1YWxpemFjYW86IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5lcSgnaWQnLCBlc3RhdGlzdGljYUV4aXN0ZW50ZS5pZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcGVyY2VudHVhbCA9IChhY2VydG9zIC8gdG90YWwpICogMTAwO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLnN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnZXN0YXRpc3RpY2FzX2FyZWFzJylcclxuICAgICAgICAgIC5pbnNlcnQoe1xyXG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXHJcbiAgICAgICAgICAgIGNhcmdvX2lkOiBjYXJnb0lkLFxyXG4gICAgICAgICAgICBhcmVhX2lkOiBhcmVhSWROdW0sXHJcbiAgICAgICAgICAgIHRvdGFsX3F1ZXN0b2VzOiB0b3RhbCxcclxuICAgICAgICAgICAgYWNlcnRvcyxcclxuICAgICAgICAgICAgcGVyY2VudHVhbFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZW1iYXJhbGhhckFycmF5PFQ+KGFycmF5OiBUW10pOiBUW10ge1xyXG4gICAgY29uc3QgZW1iYXJhbGhhZG8gPSBbLi4uYXJyYXldO1xyXG4gICAgZm9yIChsZXQgaSA9IGVtYmFyYWxoYWRvLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICBbZW1iYXJhbGhhZG9baV0sIGVtYmFyYWxoYWRvW2pdXSA9IFtlbWJhcmFsaGFkb1tqXSwgZW1iYXJhbGhhZG9baV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVtYmFyYWxoYWRvO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJMSU1JVEVfUVVFU1RPRVNfR1JBVFVJVEFTIiwiUXVlc3RvZXNTZXJ2aWNlIiwiaXNVc3VhcmlvTG9nYWRvIiwiZGF0YSIsInVzZXIiLCJlcnJvciIsInN1cGFiYXNlIiwiYXV0aCIsImdldFVzZXIiLCJidXNjYXJDYXJnb3MiLCJjYXJnb3MiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJvcmRlciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJidXNjYXJRdWVzdG9lc1BvckNhcmdvIiwiY2FyZ29JZCIsImxvZyIsInF1ZXN0b2VzIiwicXVlc3RvZXNFcnJvciIsImxlbmd0aCIsImFyZWFzIiwidG90YWwiLCJhcmVhSWRzIiwiU2V0IiwibWFwIiwicSIsImFyZWFfaWQiLCJmaWx0ZXIiLCJpZCIsImFyZWFzRXJyb3IiLCJhcmVhc0NvbVF1ZXN0b2VzIiwiYXJlYSIsImluY2x1ZGVzIiwiY2FyZ29BcmVhcyIsImNhcmdvQXJlYXNFcnJvciIsIndhcm4iLCJhcmVhTWFwIiwicmVkdWNlIiwiYWNjIiwibm9tZSIsImNhcmdvQXJlYU1hcCIsImNhIiwibnVtZXJvX3F1ZXN0b2VzIiwicGVzbyIsInF1ZXN0b2VzQ29tcGxldGFzIiwiYXJlYV9ub21lIiwicGVzb19hcmVhIiwiYXJlYXNFc3RhdGlzdGljYXMiLCJxdWVzdG9lc0RhQXJlYSIsInRvdGFsX3F1ZXN0b2VzIiwicXVlc3RvZXNfcmVzcG9uZGlkYXMiLCJhY2VydG9zIiwicGVyY2VudHVhbCIsImFyZWFJZCIsImdlcmFyU2ltdWxhZG9QZXJzb25hbGl6YWRvIiwiZGlmaWN1bGRhZGVzIiwidG9kYXNRdWVzdG9lcyIsImluIiwiY29uZmlnRXJyb3IiLCJjb25maWdBcmVhcyIsInBlc29NYXAiLCJjb25maWciLCJxdWVzdG9lc1NpbXVsYWRvIiwicXVlc3RvZXNQb3JEaWZpY3VsZGFkZSIsIm5pdmVsIiwiZGlmaWN1bGRhZGUiLCJ0b3RhbERlc2VqYWRvIiwiTWF0aCIsIm1pbiIsInF1ZXN0b2VzUG9yTml2ZWwiLCJmbG9vciIsInJlc3RvIiwiZm9yRWFjaCIsImluZGV4IiwicXVhbnRpZGFkZSIsImRpc3BvbsOtdmVpcyIsImVtYmFyYWxoYWRhcyIsImVtYmFyYWxoYXJBcnJheSIsInB1c2giLCJzbGljZSIsInF1ZXN0b2VzRGFBcmVhU2VsZWNpb25hZGFzIiwic2ltdWxhZG9GaW5hbCIsImRldmVFeGliaXJNb2RhbExvZ2luIiwicXVlc3RvZXNSZXNwb25kaWRhcyIsImlzTG9nYWRvIiwiZXhpYmlyTW9kYWwiLCJiZW5lZmljaW9zIiwicXVlc3RvZXNUb3RhaXMiLCJxdWVzdG9lc0xpYmVyYWRhcyIsInRlc3RhckNvbmV4YW8iLCJsaW1pdCIsImJ1c2NhclF1ZXN0b2VzUG9yQXJlYSIsImxpbWl0ZSIsInF1ZXN0b2VzUXVlcnkiLCJhcmVhRXJyb3IiLCJzaW5nbGUiLCJjYXJnb0FyZWEiLCJjYXJnb0FyZWFFcnJvciIsImJ1c2NhckVzdGF0aXN0aWNhc1VzdWFyaW8iLCJ1c2VySWQiLCJzdGF0cyIsInN0YXRzRXJyb3IiLCJzIiwic2FsdmFyUmVzdWx0YWRvU2ltdWxhZG8iLCJyZXNwb3N0YXMiLCJ0ZW1wb0dhc3RvIiwicG9udHVhY2FvVG90YWwiLCJwZXNvVG90YWwiLCJyZXNwb3N0YV9jb3JyZXRhIiwicGVyY2VudHVhbEFjZXJ0b3MiLCJzaW11bGFkbyIsInNpbXVsYWRvRXJyb3IiLCJpbnNlcnQiLCJ1c2VyX2lkIiwiY2FyZ29faWQiLCJ0aXBvIiwic3RhdHVzIiwiZGF0YV9jb25jbHVzYW8iLCJEYXRlIiwidG9JU09TdHJpbmciLCJ0ZW1wb19nYXN0byIsInBvbnR1YWNhb190b3RhbCIsInBlcmNlbnR1YWxfYWNlcnRvcyIsInNpbXVsYWRvX2lkIiwicXVlc3Rhb19pZCIsIm9yZGVtIiwicmVzcG9zdGFfdXN1YXJpbyIsImNvcnJldGEiLCJ0ZW1wb19yZXNwb3N0YSIsImF0dWFsaXphckVzdGF0aXN0aWNhc0FyZWFzIiwicXVlc3RvZXNQb3JBcmVhIiwiT2JqZWN0IiwiZW50cmllcyIsImFyZWFJZE51bSIsInBhcnNlSW50IiwiZXN0YXRpc3RpY2FFeGlzdGVudGUiLCJub3ZvVG90YWwiLCJub3Zvc0FjZXJ0b3MiLCJub3ZvUGVyY2VudHVhbCIsInVwZGF0ZSIsInVsdGltYV9hdHVhbGl6YWNhbyIsImFycmF5IiwiZW1iYXJhbGhhZG8iLCJpIiwiaiIsInJhbmRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/questoesServices.ts\n"));

/***/ })

});